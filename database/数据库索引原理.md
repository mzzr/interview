# 数据库索引原理
## 索引的意义
在没有索引之前，每一次查找都需要从第一行找到最后一行，进行全表扫描。
使用索引的意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。

## 什么是索引
一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。

数据库查询是数据库的最主要功能之一。希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是**索引**。

## 索引的数据结构类型
### B-Tree
B-Tree是最常用的用于索引的数据结构。因为它们是时间复杂度低，查找、删除、插入操作都可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通过决定索引应该用那些数据结构。
#### B-Tree
多路搜索树（并不是二叉的）：
1. 定义任意非叶子结点最多只有M个儿子；且M>2；
2. 根结点的儿子数为[2,M]；
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]；
4. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
6. 非叶子结点的关键字：K[1], K[2],...,K[M-1];且K[i]<K[i+1]；
7. 非叶子结点的指针：P[1], P[2], ..., P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其中P[i]指向那个关键字属于(K[i-1], K[i])的子树；
8. 所有叶子结点位于同一层；
9. 每个k对应一个data。
#####  B-Tree的搜索
B-Tree的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。
##### B-Tree的特性
1. 关键字集合分布在整颗树中；
2. 任何一个关键字出现且只出现在一个结点中；
3. 搜索有可能在非叶子结点结束；
4. 其搜索性能等价于在关键字全集内做一次二分查找；
5. 自动层次控制；
**不需要查询到叶子结点就可以，单词查询平均快于Mysql，mongodb用B-Tree索引或hash索引**

#### B+Tree
B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。
##### B+tree不同点
- 非叶子结点的子树指针与关键字个数相同；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
- 为所有叶子结点增加一个链指针
- 所有关键字都在叶子结点出现
- 非叶子结点不存储data，只存储key

##### B+Tree特性
B+的搜索与B树基本相同，区别是B+树只有打到叶子结点才命中（B-Tree可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 更适合文件索引系统；
- B+Tree的磁盘读写代价更低，内部结点并没有指向关键字具体信息的指针，因此内部结点相对B-Tree更小。如果把所有内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，减小了盘块查找时间，减小了磁盘I/O次数；
- B+Tree的查询效率更加稳定，由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所以关键字查询的路径长度相同，导致每一个数据的查询效率相当。

#### B+Tree更适合实际应用操作系统中的文件索引和数据库索引
- 不同于B-Tree只适合随机索引，B+Tree同时支持随机索引和顺序索引；
- B+树的磁盘读写代价更低，IO读写次数降低；
- B+树的查询效率更加稳定，都需要从根结点查询到叶子结点；
- B-Tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+Tree的叶子结点使用指针顺序连接在一起，只要遍历叶子结点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（效率太低）
**主要优势是范围查找与IO读写次数性能优化**

 #### 最左前缀索引
联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：

-   第一个字段一定是有序的
-   当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的

其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。

如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。

### Hash Table
hash表是另外一种用作索引的数据结构，这些索引通常被成为hash索引。使用hash索引的原因是，在寻找值时哈希表效率极高。
- 如果使用hash索引，对于等值问题，能够极快地得到检索出的值。
- hash索引的工作方式是将列的值作为索引的键值（key），和键值相对应实际的值（value）是指向该表中相应行的指针。hash表基本上可以看作是关联数组。
- hash表是无序的数据结构，因此对于很多类型的查询语句，hash索引无法避免全表扫描。作为索引的数据结构时，不像B-Tree那么灵活
#### B+Tree索引和hash索引的区别
- 如果是等值查询，那么hash索引明显有绝对优势，但如果键值不唯一，需要根据链表往后扫描
- 如果是范围查询检索，这时候哈希索引没有用，无法完成范围查询检索
- 没有办法利用索引完成排序和部分模糊查询
- 哈希索引不支持多列联合索引的最左匹配规则
- 在有大量重复键值情况下，hash索引的效率也是极低的，存在所谓的哈希碰撞问题

### R-Tree
### bitmap index

## mysql的两种存储引擎的索引存储机制
### MyISAM
MyISAM引擎使用B+Tree作为索引结构，叶子结点的data域存放的是数据记录的地址。

MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则去除其data域的值，然后以data域的值为地址，读取相应数据记录。

MyISAM的索引方式也叫做“非聚集”的。

### InnoDB
InnoDB的数据文件本身就是索引文件。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶子结点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

聚集索引（叶子结点有完整的数据记录）
InnoDB要求表必须有主键(MyISAM可以没有)，如果没有显式指定，则MySQL系统会自动选择一个可以唯一表示数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

InnoDB的辅助索引data域存储相应记录主键的值而不是地址。InnoDB的所有辅助索引都引用主键作为data域。

#### 不建议使用过长的字段作为主键
因为所有的辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
#### 非单调的字段作为主键不好
因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新纪录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择

## 索引如何提高性能
B-Tree已经排好序了，不再需要查全表了
## 索引存的是什么
数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引
## 使用数据库索引的代价
- 索引会占用空间 - 你的表越大，索引占用的空间越大
- 性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。**记住：建立在某列（或多列）索引需要保存该列最新的数据**。
**基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引**。